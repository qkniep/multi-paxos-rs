// Copyright (C) 2020 Quentin M. Kniep <hello@quentinkniep.com>
// Distributed under terms of the MIT license.

//! Contains the main algorithm for the Paxos consensus protocol.

use std::fmt::Debug;
use std::time::{Duration, Instant};

use rand::{thread_rng, Rng};
use serde::{Deserialize, Serialize};
#[allow(unused_imports)]
use tracing::{debug, error, info, trace, trace_span, warn};

use crate::udp_network::UdpNetworkNode;

/// Duration until the leader's lease expires after election.
static LEASE_DURATION: u128 = 2000; //2000 ms (= 2 seconds)

/// Unique monotonically-increasing ID.
#[derive(Serialize, Deserialize, Clone, Copy, Debug, Default, PartialEq, PartialOrd, Eq, Ord)]
pub struct Ballot(usize, usize);

impl Ballot {
    fn increment_for(&mut self, node_id: usize) {
        if self.1 > node_id {
            self.0 += 1;
        }
        self.1 = node_id;
    }
}

type PValue<V> = (usize, Ballot, V);
type Promise<V> = Vec<PValue<V>>;

/// Internal messages for the Paxos protocol.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum PaxosMsg<V: Debug> {
    Prepare {
        id: Ballot,
        holes: Vec<usize>,
    },
    Promise {
        id: Ballot,
        accepted: Promise<V>,
    },

    Propose {
        id: Ballot,
        index: usize,
        value: V,
    },
    Accept {
        id: Ballot,
        index: usize,
    },

    Learn {
        id: Ballot,
        index: usize,
        value: V,
    },

    /// Currently only used for rejecting Proposals.
    Nack {
        id: Ballot,
        index: usize,
    },

    ClientRequest(V),
}

/// Handles all Paxos related state for a single node,
/// acting as proposer, acceptor and learner.
#[derive(Debug)]
pub struct PaxosServer<V: Debug> {
    node_id: usize,
    node: UdpNetworkNode<V>,
    client_cmd_queue: Vec<V>,
    log: Vec<LogEntry<V>>,
    quorum: usize,
    // TODO: replace with Option<usize> to support the initial state w/o a leader
    current_leader: usize,
    leader_lease_start: Instant,
    random_timeout_offset: Duration,
    /// Always holds the highest Ballot number seen so far,
    /// including the ones generated by this node itself.
    highest_promised: Ballot,
    promises: Vec<(Ballot, Promise<V>)>,
}

/// Holds the state representing a single slot in the log.
#[derive(Serialize, Deserialize, Clone, Debug, Default)]
struct LogEntry<V> {
    value: Option<V>,
    acceptances: usize,
    accepted_id: Ballot,
    chosen: bool,
}

impl<V: crate::AppCommand> PaxosServer<V> {
    /// Creates a new Paxos server.
    ///
    /// # Arguments
    ///
    /// * `node` - The network node used for sending messages to other Paxos servers.
    /// * `node_id` - A unique number identifying this Paxos server.
    /// * `node_count` - The number of Paxos servers operating in this network.
    ///
    /// # Remarks
    ///
    /// At the time of creation, this server has an empty log and doesn't know who the leader is.
    pub fn new(node: UdpNetworkNode<V>, node_id: usize, node_count: usize) -> Self {
        Self {
            node_id,
            node,
            client_cmd_queue: Vec::new(),
            log: Vec::new(),
            quorum: node_count / 2 + 1,
            current_leader: 0,
            leader_lease_start: Instant::now(),
            random_timeout_offset: Duration::from_millis(thread_rng().gen_range(100, 200)),
            highest_promised: Ballot(0, 0),
            promises: Vec::new(),
        }
    }

    /// Runs this Paxos server's main loop.
    pub fn run(&mut self) {
        // configure a span to associate tracing output with this network node
        let tracing_span = trace_span!("Server", id = self.node_id);
        let _guard = tracing_span.enter();
        info!("Starting Paxos Node with ID {}", self.node_id);

        loop {
            // event loop for incoming messages
            while let Ok(msg) = self.node.recv(Duration::from_millis(100)) {
                let (src, cmd) = msg;
                self.handle_paxos_message(src, cmd);
            }

            if self.leader_lease_start.elapsed().as_millis()
                >= LEASE_DURATION + self.random_timeout_offset.as_millis()
            {
                warn!("Leader's lease timed out: Starting election.");
                self.start_election();
            } else if self.leader_lease_start.elapsed().as_millis() >= LEASE_DURATION / 2
                && self.node_id == self.current_leader
            {
                info!("Extending my lease: Starting election.");
                self.start_election();
            }
        }
    }

    /// Parses the message and calls the method corresponding to the message type.
    fn handle_paxos_message(&mut self, src: usize, cmd: PaxosMsg<V>) {
        match cmd {
            PaxosMsg::Prepare { id, holes } => self.handle_prepare(src, id, holes),
            PaxosMsg::Promise { id, accepted } => self.handle_promise(id, accepted),
            PaxosMsg::Propose { id, index, value } => self.handle_propose(src, id, index, value),
            PaxosMsg::Accept { id, index } => self.handle_accept(id, index),
            PaxosMsg::Learn { id, index, value } => self.handle_learn(id, index, value),
            PaxosMsg::Nack { id, index } => self.handle_nack(id, index),
            PaxosMsg::ClientRequest(value) => self.handle_client_request(value),
        }
    }

    /// Responds to a Paxos Prepare (1a) message.
    /// Sends a Promise back to the sender iff this node has not made Promise for a higher id yet.
    fn handle_prepare(&mut self, src: usize, id: Ballot, holes: Vec<usize>) {
        if id < self.highest_promised {
            warn!("Prepare rejected: {:?}<{:?}", id, self.highest_promised);
            return;
        } else if self.leader_lease_start.elapsed().as_millis() < LEASE_DURATION
            && src != self.current_leader
        {
            warn!(
                "Prepare rejected: {:?} currently holds the lease",
                self.current_leader
            );
            return;
        }

        debug!("Promise vote: {:?}", id);
        self.highest_promised = id;
        self.current_leader = src;
        self.leader_lease_start = Instant::now();
        self.flush_to_disk().unwrap();

        // Fills accepted_values with all values this node has accepted and
        // the sender of the Prepare has marked as not yet known to be chosen (in holes).
        let mut accepted_values = Vec::new();
        for (index, id, value) in self.get_accepted_values_iter() {
            for hole in holes.iter().copied().chain(holes.last().unwrap() + 1..) {
                if index < hole {
                    break;
                } else if hole < index {
                    continue;
                }
                accepted_values.push((index, id, value.clone()));
            }
        }

        let promise = PaxosMsg::Promise {
            id,
            accepted: accepted_values,
        };
        self.node.send(src, &promise);
    }

    /// Responds to a Paxos Promise (1b) message.
    fn handle_promise(&mut self, id: Ballot, accepted: Promise<V>) {
        if id != self.highest_promised {
            warn!("Promise rejected: {:?}!={:?}", id, self.highest_promised);
            return;
        }

        debug!("Got a promise: {:?}, {:?}", id, accepted);
        self.promises.push((id, accepted)); // TODO: Remove promises w/ old id before counting.

        if self.promises.len() == self.quorum {
            info!("Got elected.");
            self.current_leader = self.node_id;
            self.leader_lease_start = Instant::now();
            for (i, index) in (&self.log)
                .iter()
                .enumerate()
                .filter(|(_, index)| !index.chosen)
            {
                // TODO: do not chose own value if any is present in promise
                self.node.broadcast(PaxosMsg::Propose {
                    index: i,
                    id,
                    value: index.value.as_ref().unwrap().clone(),
                });
            }
        }
    }

    /// Responds to a Paxos Propose (2a) message.
    fn handle_propose(&mut self, src: usize, id: Ballot, index: usize, value: V) {
        if id < self.highest_promised {
            warn!("Proposal rejected: {:?}", value);
            self.node.send(src, &PaxosMsg::Nack { index, id });
            return;
        }

        trace!("Proposal accepted: {:?}", value);
        self.current_leader = src;
        while index >= self.log.len() {
            self.log.push(LogEntry::new());
        }
        self.node.send(src, &PaxosMsg::Accept { index, id });
        self.log[index].value = Some(value);
        self.log[index].accepted_id = id;
    }

    /// Responds to a Paxos Accept (2b) message.
    fn handle_accept(&mut self, id: Ballot, index: usize) {
        if id != self.highest_promised {
            warn!(
                "Accept rejected: [{}]: {:?}!={:?}",
                index, id, self.highest_promised
            );
            return;
        }
        self.log[index].acceptances += 1;
        if self.log[index].acceptances == self.quorum {
            debug!(
                "Sending learn with {}/{} acceptances.",
                self.log[index].acceptances, self.quorum
            );
            let value = self.log[index].value.clone().unwrap();
            info!("Value was chosen: [{}]: {:?}, {:?}", index, id, value);
            self.node.broadcast(PaxosMsg::Learn { index, id, value });
            self.log[index].chosen = true;
        }
    }

    /// Handles a Learn message.
    fn handle_learn(&mut self, id: Ballot, index: usize, value: V) {
        info!("Learned: [{}] {:?},{:?}", index, id, value);
        while index >= self.log.len() {
            self.log.push(LogEntry::new());
        }
        self.log[index].value = Some(value);
        self.log[index].accepted_id = id;
        self.log[index].chosen = true;
        self.flush_to_disk().unwrap();
    }

    /// Handles a negative acknowledgement message.
    fn handle_nack(&mut self, _id: Ballot, _index: usize) {
        warn!("Received a Nack!");
        // TODO: clean state for request #id
    }

    /// Handles a client request directly if this server believes itself to be the leader.
    /// Relays the request to the current leader otherwise.
    fn handle_client_request(&mut self, cmd: V) {
        if self.node_id == self.current_leader {
            debug!("Handling client request: {:?}", cmd);
            let value = cmd;
            self.log.push(LogEntry::new_with_value(value.clone()));
            self.node.broadcast(PaxosMsg::Propose {
                index: self.log.len() - 1,
                id: self.highest_promised,
                value,
            });
        } else {
            // TODO: is relaying to leader safe? (esp. if our current_leader value is wrong)
            trace!("Received a client request. Relaying to leader.");
            if !self
                .node
                .send(self.current_leader, &PaxosMsg::ClientRequest(cmd.clone()))
            {
                error!("Relaying command to leader failed!");
                self.client_cmd_queue.push(cmd);
            }
        }
    }

    /// Initiates a new election (Prepare/Promise sequence).
    fn start_election(&mut self) {
        self.highest_promised.increment_for(self.node_id);
        let accepted_values = self
            .get_accepted_values_iter()
            .map(|(id, i, v)| (id, i, v.clone()))
            .collect();
        self.promises = vec![(self.highest_promised, accepted_values)];

        let mut holes: Vec<usize> = (&self.log)
            .iter()
            .enumerate()
            .filter(|(_, i)| i.chosen == false)
            .map(|(index, _)| index)
            .collect();
        holes.push(self.log.len());
        debug!("Missing values: {:?}", holes);

        self.node.broadcast(PaxosMsg::Prepare {
            id: self.highest_promised,
            holes,
        });
    }

    fn flush_to_disk(&self) -> bincode::Result<()> {
        let storage = std::fs::OpenOptions::new()
            .read(true)
            .write(true)
            .create(true)
            .open("dump.bin")
            .expect("[STORAGE ERROR]: could not create stable storage");
        // TODO: flush other relevant information (e.g. highest Ballot)
        bincode::serialize_into(storage, &self.log)
    }

    fn get_accepted_values_iter(&self) -> impl Iterator<Item = (usize, Ballot, &V)> {
        (&self.log)
            .iter()
            .enumerate()
            .filter(|(_, i)| i.value.is_some())
            .map(|(index, entry)| (index, entry.accepted_id, entry.value.as_ref().unwrap()))
    }
}

impl<V> LogEntry<V> {
    fn new() -> Self {
        Self {
            value: None,
            acceptances: 0,
            accepted_id: Ballot(0, 0),
            chosen: false,
        }
    }

    fn new_with_value(value: V) -> Self {
        Self {
            value: Some(value),
            acceptances: 1,
            accepted_id: Ballot(0, 0),
            chosen: false,
        }
    }
}
