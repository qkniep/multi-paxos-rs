// Copyright (C) 2020 Quentin M. Kniep <hello@quentinkniep.com>
// Distributed under terms of the MIT license.

//! Contains the PaxosReplica which implements the main Paxos protocol logic.

use std::collections::HashMap;
use std::fmt::Debug;
use std::time::{Duration, Instant};

use rand::{thread_rng, Rng};
use tracing::{debug, error, info, info_span, trace, warn};

use crate::protocol::{Ballot, LogEntry, PaxosMsg, Promise, LEASE_DURATION};
use crate::storage::{load_from_disk_file, store_in_disk_file};
use crate::udp_network::UdpNetworkNode;

/// Handles all Paxos related state for a single node, acting as proposer, acceptor and learner.
#[derive(Debug)]
pub struct PaxosReplica<V: Debug> {
    node_id: usize,
    node: UdpNetworkNode<V>,
    client_cmd_queue: Vec<V>,
    log: Vec<LogEntry<V>>,
    /// The number of nodes which comprise a quorum (majority).
    quorum: usize,
    // TODO: replace with Option<usize> to support the initial state w/o a leader
    current_leader: usize,
    leader_lease_start: Instant,
    random_timeout_offset: Duration,
    /// Always holds the highest Ballot number seen so far,
    /// including the ones generated by this node itself.
    highest_promised: Ballot,
    promises: HashMap<usize, (Ballot, Promise<V>)>,
}

impl<V: crate::AppCommand> PaxosReplica<V> {
    /// Creates a new Paxos replica.
    ///
    /// # Arguments
    ///
    /// * `node` - The network node used for sending messages to other Paxos replicas.
    /// * `node_id` - A unique number identifying this Paxos replicas.
    /// * `node_count` - The number of Paxos replicas operating in this network.
    ///
    /// # Remarks
    ///
    /// At the time of creation, this replica has an empty log and doesn't know who the leader is.
    pub fn new(node: UdpNetworkNode<V>, node_id: usize, node_count: usize) -> Self {
        Self {
            node_id,
            node,
            client_cmd_queue: Vec::new(),
            log: Vec::new(),
            quorum: node_count / 2 + 1,
            current_leader: 0,
            leader_lease_start: Instant::now(),
            random_timeout_offset: Duration::from_millis(thread_rng().gen_range(100, 200)),
            highest_promised: Ballot::default(),
            promises: HashMap::new(),
        }
    }

    /// Runs this Paxos replica's main loop.
    pub fn run(&mut self) {
        // configure a span to associate tracing output with this network node
        let tracing_span = info_span!("Replica", id = self.node_id);
        let _guard = tracing_span.enter();
        info!("Starting Paxos Replica with ID {}", self.node_id);

        loop {
            // event loop for incoming messages
            while let Ok(msg) = self.node.recv(Duration::from_millis(100)) {
                let (src, cmd) = msg;
                self.handle_paxos_message(src, cmd);
            }

            // detect leader timeout or try to prolong our own lease
            if self.leader_lease_start.elapsed().as_millis()
                >= LEASE_DURATION + self.random_timeout_offset.as_millis()
            {
                warn!("Leader's lease timed out: Starting election.");
                self.start_election();
            } else if self.leader_lease_start.elapsed().as_millis() >= LEASE_DURATION / 2
                && self.node_id == self.current_leader
            {
                info!("Extending my lease: Starting election.");
                self.start_election();
            }
        }
    }

    /// Parses the message and calls the method corresponding to the message type.
    fn handle_paxos_message(&mut self, src: usize, cmd: PaxosMsg<V>) {
        trace!("Received a message from {}: {:?}", src, cmd);
        match cmd {
            PaxosMsg::Prepare { ballot, holes } => self.handle_prepare(src, ballot, holes),
            PaxosMsg::Promise { ballot, accepted } => self.handle_promise(src, ballot, accepted),
            PaxosMsg::Propose { index, ballot, value } => self.handle_propose(src, index, ballot, value),
            PaxosMsg::Accept { index, ballot } => self.handle_accept(src, index, ballot),
            PaxosMsg::Learn { index, ballot, value } => self.handle_learn(index, ballot, value),
            PaxosMsg::Nack { index, ballot } => self.handle_nack(index, ballot),
            PaxosMsg::ClientRequest(value) => self.handle_client_request(value),
        }
    }

    /// Responds to a Paxos Prepare (1a) message.
    /// Sends a Promise back to the sender iff this node has not made Promise for a higher ballot
    /// number yet.
    fn handle_prepare(&mut self, src: usize, ballot: Ballot, holes: Vec<usize>) {
        if ballot < self.highest_promised {
            warn!("Prepare rejected: {:?}<{:?}", ballot, self.highest_promised);
            // TODO: send NACK
            return;
        } else if self.leader_lease_start.elapsed().as_millis() < LEASE_DURATION
            && src != self.current_leader
        {
            warn!("Prepare rejected: {:?} holds lease", self.current_leader);
            // TODO: send NACK
            return;
        }

        debug!("Promise vote: {:?}", ballot);
        self.highest_promised = ballot;
        self.promises.clear();
        self.current_leader = src;
        self.leader_lease_start = Instant::now();
        self.flush_to_disk();

        // Fill accepted with all values this node has accepted and the sender
        // of the Prepare has marked as not yet known to be chosen (in holes).
        let mut accepted = Vec::new();
        for (index, ballot, value) in self.get_accepted_values_iter() {
            for hole in holes.iter().copied().chain(holes.last().unwrap() + 1..) {
                if index < hole {
                    break;
                } else if hole < index {
                    continue;
                }
                accepted.push((index, ballot, value.clone()));
            }
        }

        let promise = PaxosMsg::Promise { ballot, accepted };
        self.node.send(src, &promise);
    }

    /// Responds to a Paxos Promise (1b) message.
    fn handle_promise(&mut self, src: usize, ballot: Ballot, accepted: Promise<V>) {
        if ballot != self.highest_promised {
            warn!("Promise ignored: {:?}!={:?}", ballot, self.highest_promised);
            return;
        }

        debug!("Got a promise: {:?}, {:?}", ballot, accepted);
        // TODO: do not overwrite newer promises (out of order messages)
        self.promises.insert(src, (ballot, accepted));

        // check that we don't count old promises
        for (i, _) in self.promises.values() {
            assert_eq!(*i, self.highest_promised);
        }

        if self.promises.len() == self.quorum {
            info!("Got elected.");
            self.current_leader = self.node_id;
            self.leader_lease_start = Instant::now();

            // adapt values in log based on accepted values in received Promise messages
            for (_, accepted_values) in self.promises.values() {
                for (index, ballot, value) in accepted_values {
                    if self.log[*index].accepted_ballot < *ballot {
                        trace!(
                            "Using value from Promise: [{}] {:?}, {:?}",
                            *index,
                            *ballot,
                            value
                        );
                        self.log[*index].value = Some(value.clone());
                    }
                }
            }

            // send Propose messages for not yet chosen log entries
            for (i, entry) in self
                .log
                .iter()
                .enumerate()
                .filter(|(_, entry)| !entry.chosen)
            {
                self.node.broadcast(&PaxosMsg::Propose {
                    index: i,
                    ballot,
                    value: entry.value.clone().unwrap(),
                });
            }
        }
    }

    /// Responds to a Paxos Propose (2a) message.
    fn handle_propose(&mut self, src: usize, index: usize, ballot: Ballot, value: V) {
        if ballot < self.highest_promised {
            warn!("Proposal rejected: {:?}<{:?}", ballot, self.highest_promised);
            self.node.send(src, &PaxosMsg::Nack { index, ballot });
            return;
        }

        debug!("Proposal accepted: {:?}", value);
        self.current_leader = src;
        while index >= self.log.len() {
            self.log.push(LogEntry::default());
        }
        self.node.send(src, &PaxosMsg::Accept { index, ballot });
        self.log[index].value = Some(value);
        self.log[index].accepted_ballot = ballot;
    }

    /// Responds to a Paxos Accept (2b) message.
    fn handle_accept(&mut self, src: usize, index: usize, ballot: Ballot) {
        if ballot != self.highest_promised {
            warn!("Accept rejected: {:?}!={:?}", ballot, self.highest_promised);
            return;
        } else if self.log[index].acceptances.contains(&src) {
            warn!("Duplicate Accept ignored: [{}] {}", index, src);
            return;
        }

        self.log[index].acceptances.push(src);
        if self.log[index].acceptances.len() == self.quorum {
            debug!(
                "Sending Learn with {}/{} acceptances.",
                self.log[index].acceptances.len(),
                self.quorum
            );
            let value = self.log[index].value.clone().unwrap();
            info!("Value was chosen: [{}] {:?}, {:?}", index, ballot, value);
            self.node.broadcast(&PaxosMsg::Learn { index, ballot, value });
            self.log[index].chosen = true;
        }
    }

    /// Handles a Learn message.
    fn handle_learn(&mut self, index: usize, ballot: Ballot, value: V) {
        info!("Learned: [{}] {:?}, {:?}", index, ballot, value);
        while index >= self.log.len() {
            self.log.push(LogEntry::default());
        }
        self.log[index].value = Some(value);
        self.log[index].accepted_ballot = ballot;
        self.log[index].chosen = true;
        self.flush_to_disk();
    }

    /// Handles a negative acknowledgement message.
    fn handle_nack(&mut self, index: usize, ballot: Ballot) {
        warn!("Received a NACK.");
        // TODO: clean state for request
    }

    /// Handles a client request directly if this replica believes itself to be the leader.
    /// Relays the request to the (replica we believe to be the) current leader otherwise.
    fn handle_client_request(&mut self, cmd: V) {
        if self.node_id == self.current_leader {
            debug!("Handling client request: {:?}", cmd);
            let value = cmd;
            self.log.push(LogEntry::new(value.clone()));
            self.node.broadcast(&PaxosMsg::Propose {
                index: self.log.len() - 1,
                ballot: self.highest_promised,
                value,
            });
        } else {
            // TODO: is relaying to leader safe? (esp. if our current_leader value is wrong)
            trace!("Received a client request, relaying to leader: {:?}", cmd);
            if !self
                .node
                .send(self.current_leader, &PaxosMsg::ClientRequest(cmd.clone()))
            {
                error!("Relaying command to leader failed.");
                self.client_cmd_queue.push(cmd);
            }
        }
    }

    /// Initiates a new election, i.e. a single Prepare/Promise sequence for the whole log.
    fn start_election(&mut self) {
        self.highest_promised.increment_for(self.node_id);
        let accepted_values = self
            .get_accepted_values_iter()
            .map(|(index, ballot, value)| (index, ballot, value.clone()))
            .collect();
        self.promises.clear();
        self.promises
            .insert(self.node_id, (self.highest_promised, accepted_values));

        let mut holes: Vec<usize> = (&self.log)
            .iter()
            .enumerate()
            .filter(|(_, entry)| !entry.chosen)
            .map(|(index, _)| index)
            .collect();
        holes.push(self.log.len());
        debug!("Missing values: {:?}", holes);

        self.node.broadcast(&PaxosMsg::Prepare {
            ballot: self.highest_promised,
            holes,
        });
    }

    /// Save all persistent state for this replica to disk, or die if it doesn't work.
    fn flush_to_disk(&self) {
        store_in_disk_file("log.bin", &self.log).unwrap();
        // TODO: flush other relevant information (e.g. highest Ballot)
    }

    /// Recover this replica's state from what it previously saved to disk.
    fn recover_from_disk(&mut self) {
        self.log = load_from_disk_file("log.bin").unwrap();
        // TODO: load other relevant information (e.g. highest Ballot)
    }

    fn get_accepted_values_iter(&self) -> impl Iterator<Item = (usize, Ballot, &V)> {
        (&self.log)
            .iter()
            .enumerate()
            .filter(|(_, i)| i.value.is_some())
            .map(|(index, entry)| (index, entry.accepted_ballot, entry.value.as_ref().unwrap()))
    }
}
